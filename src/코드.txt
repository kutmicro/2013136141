<조이스틱>
//RX 모듈

#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"


//CE, CSN 핀 선언 
#define CE_PIN 7
#define CSN_PIN 8

#define motorLeftF  6
#define motorLeftB  5
#define motorRightF 10
#define motorRightB 9



//데이터 저장 배열  
int joystick[3];

//CE, CSN 핀설정
RF24 radio(CE_PIN, CSN_PIN);

//데이터 통신 할 타겟 선언
const uint64_t pipe = 0xE8E8F0F0E1LL;
 int x_value = 0, y_value = 0;

void setup(void)
{
  
  pinMode(motorLeftF,OUTPUT);
  pinMode(motorLeftB,OUTPUT);
  pinMode(motorRightF,OUTPUT);
  pinMode(motorRightB,OUTPUT);
  
  Serial.begin(9600);
  radio.begin();
  radio.setPALevel(RF24_PA_MIN); // LOW, MAX
  radio.openReadingPipe(1,pipe);
  radio.startListening();
}
void loop(void)
{
  if ( radio.available() )
  {
      radio.read( joystick, sizeof(joystick) );
        //전송된 좌표값에서 중간값(512) 제거
      x_value = (joystick[0]-512)/2;  //음수이면 후진, 양수일때 전진
      y_value = (joystick[1]-512)/2;  //음수일때 좌측, 양수일때 우측   
  }

  
  //빨간 버튼이 눌렸을 경우 정지
  if(joystick[2]==0){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);           
        }
  //y 값이 전진 일 경우
  if(y_value>80){  
        //우회전
        if(x_value>80){
         analogWrite(motorLeftF, 250);
         analogWrite(motorLeftB, 0);
         analogWrite(motorRightF, 150);
         analogWrite(motorRightB, 0);
         Serial.println("*S-R");          
        }
        //좌회전
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 150);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 250);
          analogWrite(motorRightB, 0);   
          Serial.println("*S-L*");     
         }
        //직진
        else{
          analogWrite(motorLeftF, 255);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 255);
          analogWrite(motorRightB, 0);
          Serial.println("*S*");     
        }

  }
  //x 값이 후진일 경우
  else if(y_value < -80){
        //후진 좌회전
        if(x_value>80){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 250);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 150);
          Serial.println("*B-R*");           
        }
        //후진 좌회전
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 150);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 250);
          Serial.println("*B-L*");

           
        }
        //후진
        else{
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 200);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 200);
          Serial.println("*B*");
         
           
        }


  }

  //80미만일 경우 정지
  else {
    //급격한 우측
        if(x_value>80){
          analogWrite(motorLeftF, 100);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);
          Serial.println("*R*");
                   
        }
        //급격한 좌측
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 100);
          analogWrite(motorRightB, 0);
          Serial.println("*L*");
           
        }
        //완전 정지
        else{
          analogWrite(motorLeftF,  0);
          analogWrite(motorLeftB,  0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);
          Serial.println("*STOP*");

           
        }
  }
}




<적외선 센서>
#define IRRX A0
#define LED 13

int val = 0;
void setup() {
  pinMode(LED, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  int r = analogRead(IRRX);
  if(r > 999){
    digitalWrite(LED, HIGH);
  }else{
    digitalWrite(LED, LOW);
  }
  if( abs(r - val) > 0){
    Serial.println(r);
    val = r;
    delay(100);
  }
}



<모터쉴드>
// Adafruit Motor shield library
// copyright Adafruit Industries LLC, 2009
// this code is public domain, enjoy!

#include <AFMotor.h>
#include <Servo.h> 

// DC motor on M2
AF_DCMotor motor(2);
// DC hobby servo
Servo servo1;
// Stepper motor on M3+M4 48 steps per revolution
AF_Stepper stepper(48, 2);

void setup() {
  Serial.begin(9600);           // set up Serial library at 9600 bps
  Serial.println("Motor party!");
  
  // turn on servo
  servo1.attach(9);
   
  // turn on motor #2
  motor.setSpeed(200);
  motor.run(RELEASE);
}

int i;

// Test the DC motor, stepper and servo ALL AT ONCE!
void loop() {
  motor.run(FORWARD);
  for (i=0; i<255; i++) {
    servo1.write(i);
    motor.setSpeed(i);  
    stepper.step(1, FORWARD, INTERLEAVE);
    delay(3);
 }
 
  for (i=255; i!=0; i--) {
    servo1.write(i-255);
    motor.setSpeed(i);  
    stepper.step(1, BACKWARD, INTERLEAVE);
    delay(3);
 }
 
  motor.run(BACKWARD);
  for (i=0; i<255; i++) {
    servo1.write(i);
    motor.setSpeed(i);  
    delay(3);
    stepper.step(1, FORWARD, DOUBLE);
 }
 
  for (i=255; i!=0; i--) {
    servo1.write(i-255);
    motor.setSpeed(i);  
    stepper.step(1, BACKWARD, DOUBLE);
    delay(3);
 }
}



<데이터 통신>
- Master
#include <SPI.h>
void setup (void)
{
  SPI.begin (); // SPI 통신 초기화
  digitalWrite(SS, HIGH); // 슬레이브가 선택되지 않은 상태로 유지
  // 안정적인 전송을 위해 분주비를 높여 전송 속도를 낮춤
  SPI.setClockDivider(SPI_CLOCK_DIV16);
  Serial.begin(9600);
}
void loop (void)
{
  if(Serial.available()){
    char data = Serial.read(); // 데이터 입력 확인
    if(data == 'K'){
      digitalWrite(SS, LOW); // 슬레이브를 선택한다.
      // 1바이트 데이터 수신을 위해 의미 없는 1바이트 데이터를 전송한다.
      char received = SPI.transfer(0);
      digitalWrite(SS, HIGH); // 슬레이브 선택을 해제한다.
      Serial.println(received);
    }
  }
}


- Slave
#include <SPI.h>
byte count;

void setup (void)
{
  // SPI 통신을 위한 핀들의 입출력 설정
  pinMode(MISO, OUTPUT);
  pinMode(MOSI, INPUT);
  pinMode(SCK, INPUT);
  pinMode(SS, INPUT);
  // 마스터의 전송 속도에 맞추어 통신 속도를 설정한다.
  SPI.setClockDivider(SPI_CLOCK_DIV16);
  // SPI 통신을 위한 레지스터를 설정
  SPCR |= _BV(SPE); // SPI 활성화
  SPCR &= ~_BV(MSTR); // Slave 모드 선택
  SPCR |= _BV(SPIE); // 인터럽트 허용
  count = '0'; // 카운터 초기화
}
// SPI 통신으로 데이터가 수신될 때 발생하는 인터럽트 처리 루틴
ISR (SPI_STC_vect)
{
  SPDR = count;  // 카운터 값을 ASCII 값으로 전달
}
void loop (void)
{
  count = (count + 1) ; // 카운터 값 증가

  delay(1000);
}