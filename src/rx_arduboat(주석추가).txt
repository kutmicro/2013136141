#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"


//CE, CSN 핀 선언 
#define CE_PIN 7
#define CSN_PIN 8

#define motorLeftF  6		// 왼쪽 모터의 전진 신호는 6번으로 정의
#define motorLeftB  5		// 왼쪽 모터의 후진 신호는 5번으로 정의
#define motorRightF 10		// 왼쪽 모터의 전진 신호는 10번으로 정의
#define motorRightB 9		// 왼쪽 모터의 후진 신호는 9번으로 정의



//데이터 저장 배열  
int joystick[3];

//CE, CSN 핀설정
RF24 radio(CE_PIN, CSN_PIN);

//데이터 통신 할 타겟 선언
const uint64_t pipe = 0xE8E8F0F0E1LL;
 int x_value = 0, y_value = 0;

void setup(void)
{
  
  pinMode(motorLeftF,OUTPUT);		// motorLeftF핀을 출력모드로 설정
  pinMode(motorLeftB,OUTPUT);
  pinMode(motorRightF,OUTPUT);
  pinMode(motorRightB,OUTPUT);
  
  Serial.begin(9600);
  radio.begin();
  radio.setPALevel(RF24_PA_MIN); 	// LOW, MAX
  radio.openReadingPipe(1,pipe);	// pen one of the 6 pipes for reception
  radio.startListening();		// 데이터 수신 시작
}
void loop(void)
{
  if ( radio.available() )		// 잘 모르겠음
  {
      radio.read( joystick, sizeof(joystick) );
        //전송된 좌표값에서 중간값(512) 제거
      x_value = (joystick[0]-512)/2;  //음수이면 후진, 양수일때 전진
      y_value = (joystick[1]-512)/2;  //음수일때 좌측, 양수일때 우측   
  }

  
  //빨간 버튼이 눌렸을 경우 정지
  if(joystick[2]==0){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);           
        }
  //y 값이 전진 일 경우
  if(y_value>80){  
        //우회전
        if(x_value>80){
         analogWrite(motorLeftF, 250);
         analogWrite(motorLeftB, 0);
         analogWrite(motorRightF, 150);
         analogWrite(motorRightB, 0);
         Serial.println("*S-R");          
        }
        //좌회전
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 150);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 250);
          analogWrite(motorRightB, 0);   
          Serial.println("*S-L*");     
         }
        //직진
        else{
          analogWrite(motorLeftF, 255);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 255);
          analogWrite(motorRightB, 0);
          Serial.println("*S*");     
        }

  }
  //x 값이 후진일 경우
  else if(y_value < -80){
        //후진 좌회전
        if(x_value>80){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 250);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 150);
          Serial.println("*B-R*");           
        }
        //후진 좌회전
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 150);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 250);
          Serial.println("*B-L*");

           
        }
        //후진
        else{
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 200);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 200);
          Serial.println("*B*");
         
           
        }


  }

  //80미만일 경우 정지
  else {
    //급격한 우측
        if(x_value>80){
          analogWrite(motorLeftF, 100);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);
          Serial.println("*R*");
                   
        }
        //급격한 좌측
        else if(x_value < (-80)){
          analogWrite(motorLeftF, 0);
          analogWrite(motorLeftB, 0);
          analogWrite(motorRightF, 100);
          analogWrite(motorRightB, 0);
          Serial.println("*L*");
           
        }
        //완전 정지
        else{
          analogWrite(motorLeftF,  0);
          analogWrite(motorLeftB,  0);
          analogWrite(motorRightF, 0);
          analogWrite(motorRightB, 0);
          Serial.println("*STOP*");

           
        }
  }
}